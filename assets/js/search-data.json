{
  
    
        "post0": {
            "title": "Plotting and animating colored lines in matplotlib",
            "content": "Plotting colored lines . Suppose we have a set of lines that we want to plot in matplotlib according to some color scheme. For example, each line might correspond to a contour and has some corresponding value which we would like to show on a color map. How can we go about doing this? This took me a while to figure out so this will be useful for my own future reference. . theta = np.linspace(0, 2*math.pi, 100) r = np.arange(1, 11, 1)[:, np.newaxis] x = r * np.cos(theta) y = r * np.sin(theta) fig, ax = plt.subplots() ax.plot(x.T, y.T) ax.set(xlabel=&quot;x&quot;, ylabel=&quot;y&quot;, aspect=&quot;equal&quot;) # We want to color each circle according to the corresponding value of z z = r[:, 0] . Here, x and y are 10x100 arrays representing 10 different circles as shown above. We want to color each line according to the value in z which is a length 10 array. . One way would just be to scatter plot things and let the scattered dots be colored according to z. . fig, ax = plt.subplots() paths = ax.scatter(x.T, y.T, cmap=&quot;viridis&quot;, c=np.tile(z, (100, 1))) ax.set(xlabel=&quot;x&quot;, ylabel=&quot;y&quot;, aspect=&quot;equal&quot;) axcb = fig.colorbar(paths, ax=ax) axcb.set_label(&quot;Radius&quot;) . But how can we connect these points together in a line? It turns out that we can&#39;t do the same thing with ax.plot as explained here. Instead we need to use LineCollections as explained in the answer. The code below is based on the solution provided in the answer linked. . from matplotlib.collections import LineCollection fig, ax = plt.subplots() lines = [np.column_stack([xi, yi]) for xi, yi in zip(x, y)] lc = LineCollection(lines, cmap=&quot;viridis&quot;, lw=4) # Set the values used to determine the color lc.set_array(z) ax.add_collection(lc) ax.autoscale() ax.set(xlabel=&quot;x&quot;, ylabel=&quot;y&quot;, aspect=&quot;equal&quot;) axcb = fig.colorbar(lc, ax=ax) axcb.set_label(&quot;Radius&quot;) . Animating colored lines . Now lets say we want to get fancy and we want to trace out the circles as a function of time. How can we make such an animation with our LineCollection? All we have to do is modify the above code and use FuncAnimation from matplotlib to update each frame. . import matplotlib.animation as animation fig, ax = plt.subplots() # First we initialize our line collection and add it to our Axes lines = [] lc = LineCollection(lines, cmap=&quot;viridis&quot;, lw=4) ax.add_collection(lc) def update(num): new_x = x[:, :num] new_y = y[:, :num] lines = [np.column_stack([xi, yi]) for xi, yi in zip(new_x, new_y)] # Now we update the lines in our LineCollection lc.set_segments(lines) lc.set_array(z) return lc, ani = animation.FuncAnimation(fig, update, x.shape[1], interval=100, blit=True) # For some reason autoscaling doesn&#39;t work here so we need to set the limits manually ax.set(xlabel=&quot;x&quot;, ylabel=&quot;y&quot;, aspect=&quot;equal&quot;, xlim=(-12, 12), ylim=(-12, 12)) # Put this after so that the colors are scaled properly axcb = fig.colorbar(lc) axcb.set_label(&quot;Radius&quot;) . I couldn&#39;t get rid of matplotlib showing this empty figure unfortunately... But here&#39;s the final animation! . from IPython.display import HTML HTML(ani.to_html5_video()) . Your browser does not support the video tag.",
            "url": "https://keawang.github.io/lower-the-entropy/matplotlib/notes/2020/04/01/Plotting-and-animating-colored-lines.html",
            "relUrl": "/matplotlib/notes/2020/04/01/Plotting-and-animating-colored-lines.html",
            "date": " • Apr 1, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Debugging in Jupyter notebooks",
            "content": "Intro . I have used Jupyter notebooks pretty extensively for personal projects and research experiments. But sometimes after I take an extended break from coding I find myself forgetting some of the details about how debuggers work within Jupyter notebooks. This post is mostly a reminder for myself of how to use debuggers in a notebook but hopefully it can also help others who need the same reminder. . Throughout this notebook, we will be using ipdb instead of python&#39;s built-in pdb. ipdb builds upon pdb and offers better syntax highlighting among other features. . First, we will make sure that ipdb will be used by default instead of pdb by setting the environment variable (if it isn&#39;t set already). . %set_env PYTHONBREAKPOINT=IPython.core.debugger.set_trace . env: PYTHONBREAKPOINT=IPython.core.debugger.set_trace . Setting a breakpoint within the notebook . Until python 3.7, there was only one way of setting a breakpoint in a python script. Fortunately, python 3.7 introduced the breakpoint() function with PEP 553 that makes it more convenient to set a breakpoint. . Prior to 3.7, you had to import the debugger and call set_trace(): . def foo(): print(&quot;before breakpoint&quot;) from IPython.core.debugger import set_trace; set_trace() print(&quot;after breakpoint&quot;) return foo() . before breakpoint &gt; &lt;ipython-input-2-fe3f7a7ecf85&gt;(4)foo() 2 print(&#34;before breakpoint&#34;) 3 from IPython.core.debugger import set_trace; set_trace() -&gt; 4 print(&#34;after breakpoint&#34;) 5 return 6 . after breakpoint . Fortunately, starting with python 3.7 you can do the same thing with breakpoint(). Note that python will look at the PYTHONBREAKPOINT environment variable to determine which debugger to drop into. This is why we set this variable early on. . def foo(): print(&quot;before breakpoint&quot;) breakpoint() print(&quot;after breakpoint&quot;) return foo() . before breakpoint &gt; &lt;ipython-input-3-c1ae806f7763&gt;(4)foo() 2 print(&#34;before breakpoint&#34;) 3 breakpoint() -&gt; 4 print(&#34;after breakpoint&#34;) 5 return 6 . after breakpoint . Debugging exceptions post-mortem . Jupyter notebooks allow you to do post-mortem debugging by dropping the debugger into the code leading up an unhandled exception. This is very useful when developing code because it allows you to examine the logic around the exception without having to manually set a breakpoint yourself. All you need to do is the line magic %debug . def bar(): print(&quot;This function is about to fail with an error&quot;) raise ValueError . bar() . This function is about to fail with an error . ValueError Traceback (most recent call last) &lt;ipython-input-5-226d01f48125&gt; in &lt;module&gt; -&gt; 1 bar() &lt;ipython-input-4-e0c38ffbca4e&gt; in bar() 1 def bar(): 2 print(&#34;This function is about to fail with an error&#34;) -&gt; 3 raise ValueError ValueError: . Now we use the next cell to drop into the code right before the exception to examine the cause post-mortem. . %debug . &gt; &lt;ipython-input-4-e0c38ffbca4e&gt;(3)bar() 1 def bar(): 2 print(&#34;This function is about to fail with an error&#34;) -&gt; 3 raise ValueError . You can also use the cell magic %%debug instead of breakpoint() at the top of a cell. However, I have never used %%debug because it seems to debug the execution of the cell by the notebook which causes some information to be hidden. . %%debug print(&quot;You won&#39;t see the code for this line in the stack trace&quot;) bar() . NOTE: Enter &#39;c&#39; at the ipdb&gt; prompt to continue execution. &gt; &lt;string&gt;(2)&lt;module&gt;() . You won&#39;t see the code for this line in the stack trace &gt; &lt;string&gt;(3)&lt;module&gt;() . This function is about to fail with an error ValueError &gt; &lt;string&gt;(3)&lt;module&gt;() . &gt; &lt;ipython-input-4-e0c38ffbca4e&gt;(3)bar() 1 def bar(): 2 print(&#34;This function is about to fail with an error&#34;) -&gt; 3 raise ValueError . ValueError Traceback (most recent call last) &lt;ipython-input-4-e0c38ffbca4e&gt; in bar() 1 def bar(): 2 print(&#34;This function is about to fail with an error&#34;) -&gt; 3 raise ValueError ValueError: .",
            "url": "https://keawang.github.io/lower-the-entropy/jupyter/notes/2020/03/30/Debugging-in-Jupyter.html",
            "relUrl": "/jupyter/notes/2020/03/30/Debugging-in-Jupyter.html",
            "date": " • Mar 30, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "See my homepage for information about me. .",
          "url": "https://keawang.github.io/lower-the-entropy/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  
  

  

  
  

  

  
      ,"page8": {
          "title": "",
          "content": "Warning . Do not manually save images into this folder. This is used by GitHub Actions to automatically copy images. Any images you save into this folder could be deleted at build time. .",
          "url": "https://keawang.github.io/lower-the-entropy/images/copied_from_nb/",
          "relUrl": "/images/copied_from_nb/",
          "date": ""
      }
      
  

  
  

}